<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Plane Detection Experience</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            background: #000;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            touch-action: none;
            background: transparent;
        }

        #status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            background: rgba(0,0,0,0.8);
            color: white;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 15px;
            border-radius: 15px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            text-align: center;
        }

        #ar-button {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background: linear-gradient(45deg, #007AFF, #5856D6);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,122,255,0.3);
            transition: all 0.3s ease;
        }

        #ar-button:hover {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 6px 25px rgba(0,122,255,0.4);
        }

        #ar-button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: translateX(-50%);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 1001;
            text-align: center;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Touch controls styling */
        .touch-control {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.3);
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
        }

        #zoom-in {
            bottom: 20px;
            right: 20px;
        }

        #zoom-out {
            bottom: 90px;
            right: 20px;
        }

        #zoom-reset {
            bottom: 160px;
            right: 20px;
        }

        /* AR Plane Detection Styles */
        #placement-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120px;
            height: 120px;
            border: 4px solid #00ff00;
            border-radius: 15px;
            z-index: 999;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            background: rgba(0, 255, 0, 0.1);
        }

        #placement-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 150px;
            height: 150px;
            border: 3px dashed #00ff00;
            border-radius: 20px;
            z-index: 998;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            background: rgba(0, 255, 0, 0.05);
        }

        #placement-area.visible {
            opacity: 1;
        }

        #placement-indicator.visible {
            opacity: 1;
        }

        #placement-indicator.placing {
            border-color: #ff0000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            animation: pulse 1s infinite;
        }

        #placement-indicator::before {
            content: '+';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 30px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        /* AR Controls */
        .ar-control {
            position: absolute;
            padding: 10px 15px;
            background: rgba(0,0,0,0.8);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 12px;
            z-index: 1000;
            cursor: pointer;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        #reset-button {
            top: 10px;
            left: 10px;
        }

        #scan-button {
            top: 50px;
            left: 10px;
        }

        @media (max-width: 768px) {
            #instructions {
                font-size: 12px;
                padding: 12px;
                bottom: 15px;
                left: 15px;
                right: 15px;
            }
            
            #ar-button {
                bottom: 80px;
                padding: 12px 24px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
        <div id="loading" style="display: none;">
            <div class="spinner"></div>
            <div>ƒêang kh·ªüi t·∫°o AR...</div>
        </div>
        <div id="status">S·∫µn s√†ng</div>
        <div id="camera-debug" style="position: absolute; top: 60px; right: 10px; 
                background: rgba(0,0,0,0.8); color: white; padding: 5px 10px; 
                border-radius: 10px; font-size: 12px; z-index: 1000; cursor: pointer;"
                onclick="document.getElementById('camera-debug').style.display='none'">
            üì∑ Camera: Waiting...
        </div>
        <button id="test-camera" style="position: absolute; top: 100px; right: 10px; 
                background: rgba(255,0,0,0.8); color: white; border: none; padding: 8px 12px; 
                border-radius: 10px; font-size: 12px; z-index: 1000; cursor: pointer;">
            üß™ Test Camera
        </button>
        <button id="test-place" style="position: absolute; top: 140px; right: 10px; 
                background: rgba(0,255,0,0.8); color: white; border: none; padding: 8px 12px; 
                border-radius: 10px; font-size: 12px; z-index: 1000; cursor: pointer;">
            üéØ Test Place
        </button>
        <button id="ar-button">üöÄ B·∫Øt ƒë·∫ßu AR</button>
        <button id="reset-button" class="ar-control" style="display: none;">üîÑ Reset</button>
        <button id="scan-button" class="ar-control" style="display: none;">üìè Scan Mode</button>
        <div id="placement-area"></div>
        <div id="placement-indicator"></div>
        <div class="touch-control" id="zoom-in" style="display: none;">+</div>
        <div class="touch-control" id="zoom-out" style="display: none;">‚àí</div>
        <div class="touch-control" id="zoom-reset" style="display: none;">‚åÇ</div>
        <div id="instructions">
            üöÄ Nh·∫•n "B·∫Øt ƒë·∫ßu AR" ‚Üí üìè Qu√©t m·∫∑t ph·∫≥ng ‚Üí üëÜ Ch·∫°m v√†o v√πng ƒë·ªÉ ƒë·∫∑t model ‚Üí üîÑ Di chuy·ªÉn ƒëi·ªán tho·∫°i ƒë·ªÉ xem
        </div>
    </div>

    <!-- A-Frame AR as alternative to AR.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe@1.4.0/dist/aframe-master.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ar.js@1.7.2/aframe/build/aframe-ar.min.js"></script>
    <script>
        // Wait for AR.js to load
        window.addEventListener('load', () => {
            console.log('THREEx available:', typeof THREEx !== 'undefined');
            console.log('AFRAME available:', typeof AFRAME !== 'undefined');
            
            if (typeof THREEx !== 'undefined') {
                console.log('AR.js loaded successfully');
            } else if (typeof AFRAME !== 'undefined') {
                console.log('A-Frame AR loaded successfully');
            } else {
                console.warn('Neither AR.js nor A-Frame loaded');
            }
        });
    </script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.155.0/build/three.module.min.js",
                "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        let scene, camera, renderer, model, placedModel;
        let modelScale = 1.0; // Current scale multiplier
        let video, canvas;
        let isARActive = false;
        let isScanning = true;
        let arMode = 'scanning'; // scanning, placing, placed
        
        // Touch controls
        let touchStartX = 0, touchStartY = 0;
        let isTouching = false;
        let lastTouchTime = 0;
        let touchScale = 1.0;
        let lastTouchDistance = 0;
        
        // Device orientation
        let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
        let isDeviceOrientationEnabled = false;
        
        // World space positioning
        let modelWorldPosition = new THREE.Vector3(0, 0, -2);
        let cameraDistance = 3;
        let isWorldSpaceMode = false;
        
        // AR.js integration
        let arToolkitSource, arToolkitContext, arMarkerControls;
        
        // Elements
        const status = document.getElementById('status');
        const arButton = document.getElementById('ar-button');
        const loading = document.getElementById('loading');
        const resetButton = document.getElementById('reset-button');
        const scanButton = document.getElementById('scan-button');
        const placementIndicator = document.getElementById('placement-indicator');
        const placementArea = document.getElementById('placement-area');
        const instructions = document.getElementById('instructions');
        const cameraDebug = document.getElementById('camera-debug');
        const testCameraBtn = document.getElementById('test-camera');
        const testPlaceBtn = document.getElementById('test-place');
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        const zoomResetBtn = document.getElementById('zoom-reset');

        // Initialize AR with AR.js
        async function initAR() {
            try {
                loading.style.display = 'block';
                status.textContent = 'ƒêang kh·ªüi t·∫°o AR...';
                
                // Initialize Three.js
                initThreeJS();
                
                // Initialize AR.js if available, otherwise use fallback
                if (typeof THREEx !== 'undefined') {
                    console.log('Using AR.js mode');
                    cameraDebug.textContent = 'üì∑ Camera: AR.js mode';
                    initARJS();
                } else if (typeof AFRAME !== 'undefined') {
                    console.log('Using A-Frame AR mode');
                    cameraDebug.textContent = 'üì∑ Camera: A-Frame mode';
                    initAFrameAR();
                } else {
                    console.log('No AR library available, using fallback');
                    cameraDebug.textContent = 'üì∑ Camera: Fallback mode';
                    await initCustomAR();
                }
                
                // Load 3D model
                await loadModel();
                
                loading.style.display = 'none';
                
                // Auto-start scanning mode
                arMode = 'scanning';
                status.textContent = 'ƒêang qu√©t m·∫∑t ph·∫≥ng...';
                instructions.textContent = 'üìè Di chuy·ªÉn camera ƒë·ªÉ qu√©t m·∫∑t ph·∫≥ng';
                scanButton.textContent = 'üìè Scanning...';
                
                isARActive = true;
                arButton.style.display = 'none';
                resetButton.style.display = 'block';
                scanButton.style.display = 'block';
                
                // Show placement indicator
                placementIndicator.classList.add('visible');
                
            } catch (error) {
                console.error('AR initialization failed:', error);
                loading.style.display = 'none';
                status.textContent = 'Kh√¥ng th·ªÉ kh·ªüi t·∫°o AR: ' + error.message;
                arButton.disabled = false;
                arButton.textContent = 'üöÄ Th·ª≠ l·∫°i';
            }
        }

        // Initialize Three.js
        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                alpha: true,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            canvas = document.getElementById('canvas');
            video = document.getElementById('video');
            
            // Initialize camera position for model viewing
            camera.position.set(0, 0, 3);
            camera.lookAt(0, 0, 0);
        }

        // Test camera function
        async function testCamera() {
            try {
                console.log('Testing camera access...');
                cameraDebug.textContent = 'üì∑ Camera: Testing...';
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    } 
                });
                
                // Direct video setup
                video.srcObject = stream;
                video.style.display = 'block';
                video.style.zIndex = '1';
                
                video.onloadedmetadata = () => {
                    video.play();
                    cameraDebug.textContent = 'üì∑ Camera: Working!';
                    console.log('Camera test successful');
                    console.log('Video dimensions:', video.videoWidth, 'x', video.videoHeight);
                };
                
                video.onerror = (error) => {
                    console.error('Video error:', error);
                    cameraDebug.textContent = 'üì∑ Camera: Error';
                };
                
            } catch (error) {
                console.error('Camera test failed:', error);
                cameraDebug.textContent = 'üì∑ Camera: Failed - ' + error.message;
            }
        }

        // Initialize AR.js
        function initARJS() {
            try {
                // Create AR.js source
                arToolkitSource = new THREEx.ArToolkitSource({
                    sourceType: 'webcam',
                    sourceWidth: 640,
                    sourceHeight: 480,
                    displayWidth: window.innerWidth,
                    displayHeight: window.innerHeight
                });

                // Initialize AR.js source
                arToolkitSource.init(() => {
                    // Set up video element
                    video.srcObject = arToolkitSource.domElement;
                    video.play();
                    
                    // Make sure video is visible
                    video.style.display = 'block';
                    video.style.zIndex = '1';
                    cameraDebug.textContent = 'üì∑ Camera: AR.js Active';
                    
                    // Set up AR.js context
                    arToolkitContext = new THREEx.ArToolkitContext({
                        cameraParametersUrl: 'https://cdn.jsdelivr.net/npm/ar.js@1.7.2/data/data/camera_para.dat',
                        detectionMode: 'mono_and_matrix',
                        matrixCodeType: '3x3',
                        debug: false
                    });
                    
                    arToolkitContext.init(() => {
                        camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
                    });
                    
                    // Create plane detection marker
                    createPlaneMarker();
                    
                    console.log('AR.js initialized successfully');
                });
            } catch (error) {
                console.error('AR.js initialization failed:', error);
                throw error;
            }
        }

        // Initialize A-Frame AR
        function initAFrameAR() {
            try {
                // Create A-Frame scene with AR
                const aScene = document.createElement('a-scene');
                aScene.setAttribute('embedded', '');
                aScene.setAttribute('arjs', 'sourceType: webcam; debugUIEnabled: false;');
                aScene.style.position = 'absolute';
                aScene.style.top = '0';
                aScene.style.left = '0';
                aScene.style.width = '100%';
                aScene.style.height = '100%';
                aScene.style.zIndex = '2';
                
                // Add camera
                const aCamera = document.createElement('a-camera');
                aCamera.setAttribute('gps-camera', 'rotation-reader: true;');
                aScene.appendChild(aCamera);
                
                // Add model when placed
                window.placeAFrameModel = function(x, y) {
                    const entity = document.createElement('a-entity');
                    entity.setAttribute('gltf-model', './tour360/ekana_stadium_low_poly_lucknow_city_game_asset.glb');
                    
                    // Detect mobile for scale adjustment
                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                                    window.innerWidth < 768 || 
                                    'ontouchstart' in window;
                    
                    const scale = isMobile ? '0.0005 0.0005 0.0005' : '0.0001 0.0001 0.0001';
                    const distance = isMobile ? '-0.0002' : '-0.0001';
                    
                    entity.setAttribute('scale', scale);
                    entity.setAttribute('position', `${x} ${y} ${distance}`);
                    aScene.appendChild(entity);
                };
                
                // Keep video visible, add A-Frame scene on top
                video.style.display = 'block';
                video.style.zIndex = '1';
                cameraDebug.textContent = 'üì∑ Camera: A-Frame Active';
                document.getElementById('container').appendChild(aScene);
                
                console.log('A-Frame AR initialized successfully');
            } catch (error) {
                console.error('A-Frame AR initialization failed:', error);
                throw error;
            }
        }

        // Custom AR implementation
        function initCustomAR() {
            return new Promise((resolve, reject) => {
                // Start camera manually
                navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    } 
                }).then(stream => {
                    video.srcObject = stream;
                    
                    video.onloadedmetadata = () => {
                        video.play();
                        
                        // Make sure video is visible and on top
                        video.style.display = 'block';
                        video.style.zIndex = '10';
                        video.style.position = 'absolute';
                        video.style.top = '0';
                        video.style.left = '0';
                        video.style.width = '100%';
                        video.style.height = '100%';
                        video.style.objectFit = 'cover';
                        
                        // Show canvas for model rendering
                        canvas.style.display = 'block';
                        canvas.style.zIndex = '5';
                        
                        cameraDebug.textContent = 'üì∑ Camera: Fallback Active';
                        
                        // Set up camera projection
                        camera.aspect = video.videoWidth / video.videoHeight;
                        camera.updateProjectionMatrix();
                        
                        // Create simple plane detection
                        createPlaneMarker();
                        
                        console.log('Custom AR initialized successfully');
                        console.log('Video dimensions:', video.videoWidth, 'x', video.videoHeight);
                        resolve();
                    };
                }).catch(error => {
                    console.error('Camera access failed:', error);
                    cameraDebug.textContent = 'üì∑ Camera: Failed - ' + error.message;
                    reject(error);
                });
            });
        }

        // Create plane marker for detection
        function createPlaneMarker() {
            // Create a large invisible marker that covers the entire view
            const markerGroup = new THREE.Group();
            markerGroup.userData.isMarkerGroup = true;
            
            // Add plane detection geometry with visual feedback
            const planeGeometry = new THREE.PlaneGeometry(100, 100);
            const planeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                transparent: true, 
                opacity: 0.3,
                side: THREE.DoubleSide,
                wireframe: true
            });
            const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
            planeMesh.rotation.x = -Math.PI / 2;
            planeMesh.position.y = -1;
            markerGroup.add(planeMesh);
            
            // Add grid overlay for better visual feedback
            const gridHelper = new THREE.GridHelper(20, 20, 0x00ff00, 0x00ff00);
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.5;
            gridHelper.position.y = -0.9;
            markerGroup.add(gridHelper);
            
            scene.add(markerGroup);
            
            // Make it visible when scanning
            if (arMode === 'scanning') {
                markerGroup.visible = true;
            } else {
                markerGroup.visible = false;
            }
        }

        // Load 3D model
        async function loadModel() {
            return new Promise((resolve, reject) => {
            const loader = new GLTFLoader();
                loader.load('./tour360/ekana_stadium_low_poly_lucknow_city_game_asset.glb', 
                    (gltf) => {
                model = gltf.scene;
                
                        // Detect mobile device and adjust scale
                        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                                        window.innerWidth < 768 || 
                                        'ontouchstart' in window;
                        
                        if (isMobile) {
                            // Smaller scale for mobile
                            model.scale.set(0.05, 0.05, 0.05);
                            console.log('Mobile detected - using smaller scale');
                        } else {
                            // Default scale for desktop
                            model.scale.set(0.1, 0.1, 0.1);
                            console.log('Desktop detected - using default scale');
                        }
                        
                        model.castShadow = true;
                        model.receiveShadow = true;
                        resolve(model);
                    },
                    (progress) => {
                console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%');
                    },
                    (error) => {
                        console.error('Error loading model:', error);
                        reject(error);
                    }
                );
            });
        }

        // Place model in world space
        function placeModel(x, y) {
            console.log('placeModel called with:', x, y);
            console.log('Model exists:', !!model);
            console.log('AR mode:', arMode);
            
            if (!model) {
                console.error('Model not loaded yet');
                status.textContent = 'Model ch∆∞a ƒë∆∞·ª£c t·∫£i, vui l√≤ng ƒë·ª£i...';
                return;
            }
            
            if (arMode !== 'scanning') {
                console.error('Not in scanning mode:', arMode);
                return;
            }
            
            // Show placement indicator as placing
            placementIndicator.classList.add('placing');
            status.textContent = 'ƒêang ƒë·∫∑t model...';
            
            // Convert screen coordinates to world coordinates
            const vector = new THREE.Vector3();
            vector.set(
                (x / window.innerWidth) * 4 - 2,  // X: -2 to 2
                -((y / window.innerHeight) * 4 - 2), // Y: -2 to 2
                -2  // Fixed Z distance
            );
            
            // Store world position
            modelWorldPosition.copy(vector);
            isWorldSpaceMode = true;
            
            console.log('Placing model at world position:', vector);
            
            // Create placed model
            placedModel = model.clone();
            placedModel.position.copy(vector);
            placedModel.rotation.y = Math.PI / 4;
            
            scene.add(placedModel);
            console.log('Model added to scene');
            
            arMode = 'placed';
            status.textContent = 'Model ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t';
            instructions.textContent = 'üîÑ Di chuy·ªÉn ƒëi·ªán tho·∫°i ƒë·ªÉ xem model t·ª´ c√°c g√≥c ƒë·ªô kh√°c nhau';
            placementIndicator.classList.remove('visible', 'placing');
            placementArea.classList.remove('visible');
            scanButton.textContent = '‚úÖ Model Placed';
            
            // Show zoom controls
            zoomInBtn.style.display = 'block';
            zoomOutBtn.style.display = 'block';
            zoomResetBtn.style.display = 'block';
            
            // Enable device orientation for world space tracking
            if (typeof DeviceOrientationEvent !== 'undefined' && DeviceOrientationEvent.requestPermission) {
                DeviceOrientationEvent.requestPermission().then(response => {
                    if (response === 'granted') {
                        window.addEventListener('deviceorientation', handleDeviceOrientation);
                        isDeviceOrientationEnabled = true;
                        console.log('Device orientation enabled for world space');
                    }
                });
            } else {
                window.addEventListener('deviceorientation', handleDeviceOrientation);
                isDeviceOrientationEnabled = true;
                console.log('Device orientation enabled (no permission needed)');
            }
            
            console.log('Model placement completed in world space');
        }

        // Zoom functions
        function zoomModel(direction) {
            if (!placedModel) return;
            
            const zoomFactor = 0.1;
            if (direction === 'in') {
                modelScale += zoomFactor;
            } else if (direction === 'out') {
                modelScale = Math.max(0.1, modelScale - zoomFactor);
            } else if (direction === 'reset') {
                modelScale = 1.0;
            }
            
            // Apply scale to placed model
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                            window.innerWidth < 768 || 
                            'ontouchstart' in window;
            
            const baseScale = isMobile ? 0.05 : 0.1;
            placedModel.scale.set(
                baseScale * modelScale, 
                baseScale * modelScale, 
                baseScale * modelScale
            );
            
            console.log('Model scale:', modelScale);
        }

        // Reset AR
        function resetAR() {
            if (placedModel) {
                scene.remove(placedModel);
                placedModel = null;
            }
            
            modelScale = 1.0; // Reset scale
            
            arMode = 'scanning';
            status.textContent = 'AR ƒë√£ s·∫µn s√†ng - Qu√©t m·∫∑t ph·∫≥ng';
            instructions.textContent = 'üìè Di chuy·ªÉn camera ƒë·ªÉ qu√©t m·∫∑t ph·∫≥ng';
            placementIndicator.classList.remove('visible', 'placing');
            scanButton.textContent = 'üìè Scan Mode';
            
            // Hide zoom controls
            zoomInBtn.style.display = 'none';
            zoomOutBtn.style.display = 'none';
            zoomResetBtn.style.display = 'none';
        }

        // Device orientation handler for world space tracking
        function handleDeviceOrientation(e) {
            if (!isARActive || arMode !== 'placed' || !isWorldSpaceMode) return;
            
            deviceOrientation.alpha = e.alpha || 0;
            deviceOrientation.beta = e.beta || 0;
            deviceOrientation.gamma = e.gamma || 0;
            
            // Convert to radians
            const alpha = (deviceOrientation.alpha * Math.PI) / 180;
            const beta = (deviceOrientation.beta * Math.PI) / 180;
            const gamma = (deviceOrientation.gamma * Math.PI) / 180;
            
            // Calculate camera position relative to model's world position
            const offsetX = Math.sin(alpha) * Math.cos(beta) * cameraDistance;
            const offsetY = Math.sin(beta) * cameraDistance;
            const offsetZ = Math.cos(alpha) * Math.cos(beta) * cameraDistance;
            
            // Position camera relative to model's world position
            camera.position.set(
                modelWorldPosition.x + offsetX,
                modelWorldPosition.y + offsetY,
                modelWorldPosition.z + offsetZ
            );
            
            // Always look at the model's world position
            camera.lookAt(modelWorldPosition);
            
            // Auto-adjust distance based on device movement
            updateCameraDistance();
        }

        // Update camera distance based on device movement
        function updateCameraDistance() {
            if (!isWorldSpaceMode) return;
            
            // Calculate current distance from model
            const currentDistance = camera.position.distanceTo(modelWorldPosition);
            
            // Auto-adjust zoom based on distance
            const targetDistance = Math.max(1, Math.min(5, currentDistance));
            cameraDistance = targetDistance;
            
            // Update model scale based on distance
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                            window.innerWidth < 768 || 
                            'ontouchstart' in window;
            
            const baseScale = isMobile ? 0.05 : 0.1;
            const distanceScale = Math.max(0.5, Math.min(2, targetDistance / 3));
            const finalScale = baseScale * distanceScale * modelScale;
            
            if (placedModel) {
                placedModel.scale.set(finalScale, finalScale, finalScale);
            }
        }

        // Render loop
        function render() {
            if (!isARActive) return;
            
            // Update AR.js if available
            if (arToolkitSource && arToolkitSource.ready && arToolkitContext) {
                arToolkitContext.update(arToolkitSource.domElement);
            }
            
            // Show placement indicator when scanning
            if (arMode === 'scanning') {
                placementIndicator.classList.add('visible');
                placementArea.classList.add('visible');
                // Show plane detection grid
                const markerGroup = scene.children.find(child => child.userData.isMarkerGroup);
                if (markerGroup) {
                    markerGroup.visible = true;
                }
            } else {
                placementIndicator.classList.remove('visible', 'placing');
                placementArea.classList.remove('visible');
                // Hide plane detection grid when model is placed
                const markerGroup = scene.children.find(child => child.userData.isMarkerGroup);
                if (markerGroup) {
                    markerGroup.visible = false;
                }
            }
            
            // Render scene
            renderer.render(scene, camera);
        }

        // Event listeners
        arButton.addEventListener('click', initAR);
        testCameraBtn.addEventListener('click', testCamera);
        testPlaceBtn.addEventListener('click', () => {
            console.log('Test place button clicked');
            if (isARActive && arMode === 'scanning') {
                placeModel(window.innerWidth / 2, window.innerHeight / 2);
            } else {
                alert('AR ch∆∞a kh·ªüi ƒë·ªông ho·∫∑c kh√¥ng ·ªü ch·∫ø ƒë·ªô scanning');
            }
        });
        
        resetButton.addEventListener('click', resetAR);
        
        // Zoom controls
        zoomInBtn.addEventListener('click', () => zoomModel('in'));
        zoomOutBtn.addEventListener('click', () => zoomModel('out'));
        zoomResetBtn.addEventListener('click', () => zoomModel('reset'));
        
        scanButton.addEventListener('click', () => {
            if (arMode === 'scanning') {
                status.textContent = 'Ch·∫°m v√†o m√†n h√¨nh ƒë·ªÉ ƒë·∫∑t model';
                instructions.textContent = 'üëÜ Ch·∫°m v√†o v·ªã tr√≠ mu·ªën ƒë·∫∑t model';
                placementIndicator.classList.add('placing');
            }
        });
        
        
        // Touch handlers for manual controls (only when not in world space mode)
        function handleTouchStart(e) {
            if (!isARActive || arMode !== 'placed' || isWorldSpaceMode) return;
            e.preventDefault();
            
            if (e.touches.length === 1) {
                // Single touch - rotation
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                isTouching = true;
                lastTouchTime = Date.now();
            } else if (e.touches.length === 2) {
                // Two touches - pinch to zoom
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                lastTouchDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) + 
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
            }
        }

        function handleTouchMove(e) {
            if (!isARActive || arMode !== 'placed' || isWorldSpaceMode) return;
            e.preventDefault();
            
            if (e.touches.length === 1 && isTouching) {
                // Single touch rotation
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;
                
                // Rotate camera around model
                const rotationSpeed = 0.01;
                camera.position.x = Math.sin(deltaX * rotationSpeed) * 3;
                camera.position.z = Math.cos(deltaX * rotationSpeed) * 3;
                camera.position.y = Math.sin(deltaY * rotationSpeed) * 2;
                camera.lookAt(0, 0, 0);
                
            } else if (e.touches.length === 2) {
                // Two touches - pinch to zoom
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) + 
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                
                if (lastTouchDistance > 0) {
                    const scaleChange = currentDistance / lastTouchDistance;
                    zoomModel(scaleChange > 1 ? 'in' : 'out');
                }
                lastTouchDistance = currentDistance;
            }
        }

        function handleTouchEnd(e) {
            if (!isARActive || arMode !== 'placed' || isWorldSpaceMode) return;
            e.preventDefault();
            
            isTouching = false;
            lastTouchDistance = 0;
            
            // Check for tap (quick touch)
            if (Date.now() - lastTouchTime < 200 && e.touches.length === 0) {
                // This was a tap, not a drag
                return;
            }
        }

        // Handle tap to place - use document to catch all clicks
        document.addEventListener('click', (e) => {
            console.log('Click detected:', e.clientX, e.clientY);
            if (!isARActive || arMode !== 'scanning') {
                console.log('AR not active or not in scanning mode');
                return;
            }
            
            const x = e.clientX;
            const y = e.clientY;
            
            console.log('Calling placeModel with:', x, y);
            placeModel(x, y);
        });
        
        // Touch support - use document to catch all touches
        document.addEventListener('touchstart', (e) => {
            if (!isARActive) return;
            
            if (arMode === 'scanning') {
                // Placement mode
                console.log('Touch detected for placement');
                e.preventDefault();
                
                const touch = e.touches[0];
                const x = touch.clientX;
                const y = touch.clientY;
                
                console.log('Calling placeModel with touch:', x, y);
                placeModel(x, y);
            } else if (arMode === 'placed') {
                // Model interaction mode
                handleTouchStart(e);
            }
        });

        document.addEventListener('touchmove', handleTouchMove);
        document.addEventListener('touchend', handleTouchEnd);

        // Window resize
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                if (arToolkitSource) {
                    arToolkitSource.onResize();
                }
            }
        });

        // Start render loop
        function animate() {
            requestAnimationFrame(animate);
            render();
        }
        
        animate();
        
        // Debug AR.js availability
        window.addEventListener('load', () => {
            console.log('THREEx available:', typeof THREEx !== 'undefined');
            console.log('Three.js available:', typeof THREE !== 'undefined');
            if (typeof THREEx !== 'undefined') {
                console.log('AR.js loaded successfully');
            } else {
                console.warn('AR.js not loaded - will use fallback mode');
            }
        });
        
        console.log('AR Plane Detection with AR.js initialized');
    </script>
</body>
</html>
