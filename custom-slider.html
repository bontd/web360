<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Custom Slider - 1 Big + 2 Small</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .custom-slider {
      width: 100%;
      max-width: 1200px;
      padding: 40px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    .slider-grid {
      position: relative;
      height: 500px;
      margin-bottom: 30px;
      overflow: hidden;
      border-radius: 15px;
    }

    /* Slider track - chứa tất cả slides */
    .slider-track {
      display: flex;
      gap: 20px;
      height: 100%;
      transition: transform 0.8s cubic-bezier(0.4, 0.0, 0.2, 1);
      will-change: transform;
    }

    .slider-track.no-transition {
      transition: none !important;
    }

    /* Mỗi slide item - Width-based approach đơn giản */
    .slide-item {
      width: 700px; /* Width mặc định cho slide lớn */
      height: 100%;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      position: relative;
      flex-shrink: 0;
      transition: width 0.8s cubic-bezier(0.4, 0.0, 0.2, 1),
                  box-shadow 0.3s ease,
                  transform 0.3s ease;
    }

    /* Disable transitions khi reset */
    .slide-item.no-transition {
      transition: none !important;
    }

    .slide-item.small {
      width: 200px; /* Width cho slide nhỏ */
      cursor: pointer;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    .slide-item.small:hover {
      transform: scale(1.05);
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
      z-index: 10;
    }

    .slide-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    /* Slide indicators */
    .slide-item.small::before {
      content: 'Click';
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(102, 126, 234, 0.9);
      color: white;
      padding: 5px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: bold;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .slide-item.small:hover::before {
      opacity: 1;
    }

    /* Legacy classes - not used but kept for compatibility */
    .big-slide, .small-slides {
      display: none;
    }

    /* Controls */
    .controls {
      display: flex;
      justify-content: center;
      gap: 20px;
      align-items: center;
    }

    .controls button {
      width: 60px;
      height: 60px;
      border: none;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .controls button:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
    }

    .controls button:active {
      transform: scale(0.95);
    }

    .controls button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: scale(1);
    }

    /* Slide counter */
    .slide-counter {
      background: rgba(255, 255, 255, 0.2);
      padding: 10px 20px;
      border-radius: 25px;
      color: white;
      font-weight: bold;
      font-size: 16px;
      backdrop-filter: blur(5px);
    }

    /* Autoplay indicator */
    .autoplay-toggle {
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid white;
      color: white;
      padding: 10px 20px;
      border-radius: 25px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
      backdrop-filter: blur(5px);
    }

    .autoplay-toggle:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .autoplay-toggle.active {
      background: rgba(102, 126, 234, 0.8);
    }

    /* Responsive */
    @media (max-width: 768px) {
      .slider-grid {
        height: 300px;
      }

      .slide-item {
        width: 300px;
      }

      .slide-item.small {
        width: 150px;
      }

      .controls button {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }

      .custom-slider {
        padding: 20px;
      }
    }

    @media (max-width: 480px) {
      .slide-item {
        width: 250px;
      }

      .slide-item.small {
        width: 120px;
      }
    }

    /* Loading effect */
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 18px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="custom-slider">
    <div class="slider-grid">
      <div class="slider-track" id="sliderTrack">
        <!-- Slides will be generated dynamically -->
      </div>
    </div>

    <!-- Controls -->
    <div class="controls">
      <button id="prevBtn" aria-label="Previous slide">←</button>
      
      <div class="slide-counter">
        <span id="currentSlide">1</span> / <span id="totalSlides">3</span>
      </div>

      <button id="nextBtn" aria-label="Next slide">→</button>

      <button class="autoplay-toggle" id="autoplayBtn">
        ▶ Auto
      </button>
    </div>
  </div>

  <script>
    // Cấu hình slider
    const CONFIG = {
      images: [
        "images/slide-01.png",
        "images/slide-02.jpg",
        "images/slide-03.jpg",
      ],
      animationDuration: 800, // ms
      autoplayInterval: 3000, // ms
      enableAutoplay: false,
      enableKeyboard: true,
      enableSwipe: true,
    };

    // State
    let currentIndex = 0;
    let isAnimating = false;
    let autoplayTimer = null;
    let isAutoplayActive = false;
    
    // Cache widths for performance
    let cachedSmallWidth = 200;
    let cachedBigWidth = 700;
    
    function updateCachedWidths() {
      const tempSmall = document.createElement('div');
      tempSmall.className = 'slide-item small';
      tempSmall.style.visibility = 'hidden';
      tempSmall.style.position = 'absolute';
      document.body.appendChild(tempSmall);
      cachedSmallWidth = tempSmall.offsetWidth;
      document.body.removeChild(tempSmall);
      
      const tempBig = document.createElement('div');
      tempBig.className = 'slide-item';
      tempBig.style.visibility = 'hidden';
      tempBig.style.position = 'absolute';
      document.body.appendChild(tempBig);
      cachedBigWidth = tempBig.offsetWidth;
      document.body.removeChild(tempBig);
    }

    // DOM Elements
    const sliderTrack = document.getElementById('sliderTrack');
    const nextBtn = document.getElementById('nextBtn');
    const prevBtn = document.getElementById('prevBtn');
    const autoplayBtn = document.getElementById('autoplayBtn');
    const currentSlideEl = document.getElementById('currentSlide');
    const totalSlidesEl = document.getElementById('totalSlides');

    // Initialize
    function init() {
      updateCachedWidths();
      totalSlidesEl.textContent = CONFIG.images.length;
      buildSlider();
      updateCounter();

      // Event listeners
      nextBtn.addEventListener('click', nextSlide);
      prevBtn.addEventListener('click', prevSlide);
      autoplayBtn.addEventListener('click', toggleAutoplay);

      // Keyboard navigation
      if (CONFIG.enableKeyboard) {
        document.addEventListener('keydown', handleKeyboard);
      }

      // Touch swipe
      if (CONFIG.enableSwipe) {
        setupSwipe();
      }

      // Start autoplay if enabled
      if (CONFIG.enableAutoplay) {
        startAutoplay();
      }
    }

    // Build slider với infinite loop
    function buildSlider() {
      sliderTrack.innerHTML = '';
      
      // Clone images 3 lần để tạo infinite effect
      const extendedImages = [
        ...CONFIG.images,
        ...CONFIG.images,
        ...CONFIG.images
      ];

      extendedImages.forEach((imgSrc, index) => {
        const slideDiv = document.createElement('div');
        const relativeIndex = index % CONFIG.images.length;
        
        // Mặc định tất cả đều là small
        slideDiv.className = 'slide-item small';
        slideDiv.onclick = () => {
          const offset = index - currentIndex;
          if (offset !== 0) jumpToSlide(offset);
        };

        const img = document.createElement('img');
        img.src = imgSrc;
        img.alt = `Slide ${relativeIndex + 1}`;
        
        slideDiv.appendChild(img);
        sliderTrack.appendChild(slideDiv);
      });

      // Update which slide is "big" based on current index
      updateSlideClasses();
      
      // Position at current slide
      updatePosition(false);
    }

    // Update slide classes based on current index
    function updateSlideClasses() {
      const slides = sliderTrack.querySelectorAll('.slide-item');
      slides.forEach((slide, index) => {
        if (index === currentIndex) {
          slide.className = 'slide-item'; // Big slide
        } else {
          slide.className = 'slide-item small'; // Small slides
        }
      });
    }

    // Update slider position với fixed width pattern
    function updatePosition(animate = true) {
      const gap = 20;
      
      // Use cached width (responsive)
      const smallWidth = cachedSmallWidth;
      
      // Tất cả slides trước currentIndex đều là small (sau khi updateSlideClasses)
      // Slide tại currentIndex là big
      const offset = currentIndex * (smallWidth + gap);
      
      if (!animate) {
        sliderTrack.style.transition = 'none';
      } else {
        sliderTrack.style.transition = 'transform 0.8s cubic-bezier(0.4, 0.0, 0.2, 1)';
      }
      
      sliderTrack.style.transform = `translateX(-${offset}px)`;
      
      if (!animate) {
        // Force reflow
        sliderTrack.offsetHeight;
        sliderTrack.style.transition = '';
      }
    }

    // Update counter
    function updateCounter() {
      const displayIndex = ((currentIndex % CONFIG.images.length) + CONFIG.images.length) % CONFIG.images.length;
      currentSlideEl.textContent = displayIndex + 1;
    }

    // Next slide - Slide từ phải qua trái
    function nextSlide() {
      if (isAnimating) return;
      isAnimating = true;

      currentIndex++;
      updateSlideClasses();
      
      requestAnimationFrame(() => {
        updatePosition(true);
        updateCounter();
      });

      setTimeout(() => {
        isAnimating = false;
        
        // Reset SAU animation nếu cần - silent jump với no transition
        if (currentIndex >= CONFIG.images.length * 2) {
          setTimeout(() => {
            const slides = sliderTrack.querySelectorAll('.slide-item');
            
            // 1. Disable tất cả transitions
            slides.forEach(slide => slide.classList.add('no-transition'));
            sliderTrack.classList.add('no-transition');
            
            // 2. Update index
            currentIndex = CONFIG.images.length;
            
            // 3. Update classes (big/small)
            slides.forEach((slide, index) => {
              if (index === currentIndex) {
                slide.className = 'slide-item no-transition';
              } else {
                slide.className = 'slide-item small no-transition';
              }
            });
            
            // 4. Update position
            updatePosition(false);
            updateCounter();
            
            // 5. Force reflow
            sliderTrack.offsetHeight;
            
            // 6. Re-enable transitions
            slides.forEach(slide => slide.classList.remove('no-transition'));
            sliderTrack.classList.remove('no-transition');
          }, 50);
        }
      }, CONFIG.animationDuration);

      resetAutoplay();
    }

    // Previous slide - Slide từ trái qua phải
    function prevSlide() {
      if (isAnimating) return;
      isAnimating = true;

      currentIndex--;
      updateSlideClasses();
      
      requestAnimationFrame(() => {
        updatePosition(true);
        updateCounter();
      });

      setTimeout(() => {
        isAnimating = false;
        
        // Reset SAU animation nếu cần - silent jump với no transition
        if (currentIndex < CONFIG.images.length) {
          setTimeout(() => {
            const slides = sliderTrack.querySelectorAll('.slide-item');
            
            // 1. Disable tất cả transitions
            slides.forEach(slide => slide.classList.add('no-transition'));
            sliderTrack.classList.add('no-transition');
            
            // 2. Update index
            currentIndex = CONFIG.images.length * 2 - 1;
            
            // 3. Update classes (big/small)
            slides.forEach((slide, index) => {
              if (index === currentIndex) {
                slide.className = 'slide-item no-transition';
              } else {
                slide.className = 'slide-item small no-transition';
              }
            });
            
            // 4. Update position
            updatePosition(false);
            updateCounter();
            
            // 5. Force reflow
            sliderTrack.offsetHeight;
            
            // 6. Re-enable transitions
            slides.forEach(slide => slide.classList.remove('no-transition'));
            sliderTrack.classList.remove('no-transition');
          }, 50);
        }
      }, CONFIG.animationDuration);

      resetAutoplay();
    }

    // Jump to specific slide
    function jumpToSlide(offset) {
      if (isAnimating || offset === 0) return;
      
      if (offset > 0) {
        for (let i = 0; i < offset; i++) {
          setTimeout(() => nextSlide(), i * CONFIG.animationDuration);
        }
      } else {
        for (let i = 0; i < Math.abs(offset); i++) {
          setTimeout(() => prevSlide(), i * CONFIG.animationDuration);
        }
      }
    }

    // Autoplay functions
    function startAutoplay() {
      if (autoplayTimer) clearInterval(autoplayTimer);
      autoplayTimer = setInterval(nextSlide, CONFIG.autoplayInterval);
      isAutoplayActive = true;
      autoplayBtn.classList.add('active');
      autoplayBtn.textContent = '⏸ Auto';
    }

    function stopAutoplay() {
      if (autoplayTimer) {
        clearInterval(autoplayTimer);
        autoplayTimer = null;
      }
      isAutoplayActive = false;
      autoplayBtn.classList.remove('active');
      autoplayBtn.textContent = '▶ Auto';
    }

    function toggleAutoplay() {
      if (isAutoplayActive) {
        stopAutoplay();
      } else {
        startAutoplay();
      }
    }

    function resetAutoplay() {
      if (isAutoplayActive) {
        stopAutoplay();
        startAutoplay();
      }
    }

    // Keyboard navigation
    function handleKeyboard(e) {
      if (e.key === 'ArrowRight') {
        nextSlide();
      } else if (e.key === 'ArrowLeft') {
        prevSlide();
      } else if (e.key === ' ') {
        e.preventDefault();
        toggleAutoplay();
      }
    }

    // Simple swipe detection
    function setupSwipe() {
      let touchStartX = 0;
      let touchEndX = 0;

      sliderTrack.addEventListener('touchstart', e => {
        touchStartX = e.changedTouches[0].screenX;
      });

      sliderTrack.addEventListener('touchend', e => {
        touchEndX = e.changedTouches[0].screenX;
        handleSwipe();
      });

      function handleSwipe() {
        const swipeThreshold = 50;
        const diff = touchStartX - touchEndX;

        if (Math.abs(diff) > swipeThreshold) {
          if (diff > 0) {
            nextSlide();
          } else {
            prevSlide();
          }
        }
      }
    }

    // Rebuild slider on resize
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        updateCachedWidths();
        buildSlider();
      }, 250);
    });

    // Pause autoplay when page is hidden
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        if (isAutoplayActive) {
          stopAutoplay();
        }
      } else {
        if (CONFIG.enableAutoplay) {
          startAutoplay();
        }
      }
    });

    // Start the slider
    currentIndex = CONFIG.images.length; // Start at middle
    init();
  </script>
</body>
</html>

